-- GENERATED by C->Haskell Compiler, version 0.16.2 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "System/LibVirt/Foreign.chs" #-}{-# LANGUAGE ForeignFunctionInterface #-}


{-# LINE 3 "System/LibVirt/Foreign.chs" #-}


module System.LibVirt.Foreign
  (-- * Types
   Connection, Domain, 
   DomainID,
   DomainInfo (..),
   DomainState (..),
   Stream,
   DomainCreateFlags (..),
   DomainXMLFlags (..),
   SecurityLabel (..),
   SecurityModel (..),
   NodeInfo (..),
   SchedParameterType (..),
   ConnectCredential (..),

   -- * Connection management functions
   initialize,
   openConnection, closeConnection,

   -- * Domains management functions
   runningDomainsCount, definedDomainsCount,
   runningDomainsIDs, definedDomainsNames,
   lookupDomainID, lookupDomainName,
   getDomainInfo, getDomainXML,
   defineDomainXML, undefineDomain,

   -- * Domains control
   createDomain, createDomainXML,
   destroyDomain, 
   shutdownDomain, rebootDomain,
   suspendDomain, resumeDomain,
   saveDomain, restoreDomain,
   refDomain, freeDomain
  ) where

import Data.Bits
import Foreign
import Foreign.C.Types
import Foreign.C.String

cIntConv = fromIntegral

newtype Connection = Connection (Ptr (Connection))
{-# LINE 49 "System/LibVirt/Foreign.chs" #-}

ptrToConnection :: Ptr () -> Connection
ptrToConnection ptr = Connection (castPtr ptr)

connectionToPtr :: Connection -> Ptr ()
connectionToPtr (Connection ptr) = castPtr ptr

newtype Domain = Domain (Ptr (Domain))
{-# LINE 57 "System/LibVirt/Foreign.chs" #-}

ptrToDomain :: Ptr () -> Domain
ptrToDomain ptr = Domain (castPtr ptr)

domainToPtr :: Domain -> Ptr ()
domainToPtr (Domain ptr) = castPtr ptr

cuchar2state :: CUChar -> DomainState
cuchar2state c = toEnum (fromIntegral c)

flags2int :: (Enum f, Num a) => [f] -> a
flags2int list = fromIntegral $ foldr (.|.) 0 (map fromEnum list)

data DomainInfo = DomainInfo {
  diState :: DomainState,
  diMaxMem :: Integer,
  diMemory :: Integer,
  diNrVirtCPU :: Int,
  diCPUTime :: Integer }
  deriving (Eq, Show)

type DomainInfoPtr = Ptr (DomainInfo)
{-# LINE 79 "System/LibVirt/Foreign.chs" #-}

data DomainState = DomainNostate
                 | DomainRunning
                 | DomainBlocked
                 | DomainPaused
                 | DomainShutdown
                 | DomainShutoff
                 | DomainCrashed
                 deriving (Eq,Show)
instance Enum DomainState where
  fromEnum DomainNostate = 0
  fromEnum DomainRunning = 1
  fromEnum DomainBlocked = 2
  fromEnum DomainPaused = 3
  fromEnum DomainShutdown = 4
  fromEnum DomainShutoff = 5
  fromEnum DomainCrashed = 6

  toEnum 0 = DomainNostate
  toEnum 1 = DomainRunning
  toEnum 2 = DomainBlocked
  toEnum 3 = DomainPaused
  toEnum 4 = DomainShutdown
  toEnum 5 = DomainShutoff
  toEnum 6 = DomainCrashed
  toEnum unmatched = error ("DomainState.toEnum: Cannot match " ++ show unmatched)

{-# LINE 81 "System/LibVirt/Foreign.chs" #-}
data DomainCreateFlags = DomainNone
                       | DomainStartPaused
                       deriving (Eq,Show)
instance Enum DomainCreateFlags where
  fromEnum DomainNone = 0
  fromEnum DomainStartPaused = 1

  toEnum 0 = DomainNone
  toEnum 1 = DomainStartPaused
  toEnum unmatched = error ("DomainCreateFlags.toEnum: Cannot match " ++ show unmatched)

{-# LINE 82 "System/LibVirt/Foreign.chs" #-}
data DomainXMLFlags = DomainXmlSecure
                    | DomainXmlInactive
                    | DomainXmlUpdateCpu
                    deriving (Eq,Show)
instance Enum DomainXMLFlags where
  fromEnum DomainXmlSecure = 1
  fromEnum DomainXmlInactive = 2
  fromEnum DomainXmlUpdateCpu = 4

  toEnum 1 = DomainXmlSecure
  toEnum 2 = DomainXmlInactive
  toEnum 4 = DomainXmlUpdateCpu
  toEnum unmatched = error ("DomainXMLFlags.toEnum: Cannot match " ++ show unmatched)

{-# LINE 83 "System/LibVirt/Foreign.chs" #-}

newtype Stream = Stream (Ptr (Stream))
{-# LINE 85 "System/LibVirt/Foreign.chs" #-}

data SecurityLabel = SecurityLabel {
  slLabel :: String,
  slEnforcing :: Int }
  deriving (Eq, Show)

type SecurityLabelPtr = Ptr (SecurityLabel)
{-# LINE 92 "System/LibVirt/Foreign.chs" #-}

data SecurityModel = SecurityModel {
  smModel :: String,
  smDOI :: String }
  deriving (Eq, Show)

type SecurityModelPtr = Ptr (SecurityModel)
{-# LINE 99 "System/LibVirt/Foreign.chs" #-}

data NodeInfo = NodeInfo {
  niModel :: String,
  niMemory :: CULong,
  niCPUs :: CUInt,
  niMHz :: CUInt,
  niNodes :: CUInt,
  niSockets :: CUInt,
  niCores :: CUInt,
  niThreads :: CUInt }
  deriving (Eq, Show)

type NodeInfoPtr = Ptr (NodeInfo)
{-# LINE 112 "System/LibVirt/Foreign.chs" #-}

data SchedParameterType = DomainSchedFieldInt
                        | DomainSchedFieldUint
                        | DomainSchedFieldLlong
                        | DomainSchedFieldUllong
                        | DomainSchedFieldDouble
                        | DomainSchedFieldBoolean
                        deriving (Eq,Show)
instance Enum SchedParameterType where
  fromEnum DomainSchedFieldInt = 1
  fromEnum DomainSchedFieldUint = 2
  fromEnum DomainSchedFieldLlong = 3
  fromEnum DomainSchedFieldUllong = 4
  fromEnum DomainSchedFieldDouble = 5
  fromEnum DomainSchedFieldBoolean = 6

  toEnum 1 = DomainSchedFieldInt
  toEnum 2 = DomainSchedFieldUint
  toEnum 3 = DomainSchedFieldLlong
  toEnum 4 = DomainSchedFieldUllong
  toEnum 5 = DomainSchedFieldDouble
  toEnum 6 = DomainSchedFieldBoolean
  toEnum unmatched = error ("SchedParameterType.toEnum: Cannot match " ++ show unmatched)

{-# LINE 114 "System/LibVirt/Foreign.chs" #-}

data ConnectCredential = ConnectCredential {
  ccType :: Int,
  ccPrompt :: String,
  ccChallenge :: String,
  ccDefresult :: String,
  ccResult :: String,
  ccResultLen :: Integer }
  deriving (Eq, Show)

type ConnectCredentialPtr = Ptr (ConnectCredential)
{-# LINE 125 "System/LibVirt/Foreign.chs" #-}

initialize :: IO (Int)
initialize =
  initialize'_ >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 127 "System/LibVirt/Foreign.chs" #-}

openConnection :: String -> IO (Connection)
openConnection a1 =
  withCString a1 $ \a1' -> 
  openConnection'_ a1' >>= \res ->
  let {res' = ptrToConnection res} in
  return (res')
{-# LINE 130 "System/LibVirt/Foreign.chs" #-}

closeConnection :: Connection -> IO (Int)
closeConnection a1 =
  let {a1' = connectionToPtr a1} in 
  closeConnection'_ a1' >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 133 "System/LibVirt/Foreign.chs" #-}

runningDomainsCount :: Connection -> IO (Int)
runningDomainsCount a1 =
  let {a1' = connectionToPtr a1} in 
  runningDomainsCount'_ a1' >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 136 "System/LibVirt/Foreign.chs" #-}

type DomainID = CInt

runningDomainsIDs :: Connection -> IO [DomainID]
runningDomainsIDs conn = do
  cn <- virConnectNumOfDomains (connectionToPtr conn)
  let n = fromIntegral cn
  r <- allocaArray n $ \arr -> do
          r <- virConnectListDomains
{-# LINE 145 "System/LibVirt/Foreign.chs" #-}
                  (connectionToPtr conn) arr cn
          peekArray n arr
  return r

definedDomainsNames :: Connection -> IO [String]
definedDomainsNames conn = do
  cn <- virConnectNumOfDefinedDomains (connectionToPtr conn)
  let n = fromIntegral cn
  allocaArray n $ \nptr -> do
    virConnectListDefinedDomains
{-# LINE 155 "System/LibVirt/Foreign.chs" #-}
        (connectionToPtr conn) nptr cn
    mapM peekCString =<< peekArray n nptr

lookupDomainID :: Connection -> DomainID -> IO (Domain)
lookupDomainID a1 a2 =
  let {a1' = connectionToPtr a1} in 
  let {a2' = id a2} in 
  lookupDomainID'_ a1' a2' >>= \res ->
  let {res' = ptrToDomain res} in
  return (res')
{-# LINE 161 "System/LibVirt/Foreign.chs" #-}

lookupDomainName :: Connection -> String -> IO (Domain)
lookupDomainName a1 a2 =
  let {a1' = connectionToPtr a1} in 
  withCString a2 $ \a2' -> 
  lookupDomainName'_ a1' a2' >>= \res ->
  let {res' = ptrToDomain res} in
  return (res')
{-# LINE 165 "System/LibVirt/Foreign.chs" #-}

definedDomainsCount :: Connection -> IO (Int)
definedDomainsCount a1 =
  let {a1' = connectionToPtr a1} in 
  definedDomainsCount'_ a1' >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 168 "System/LibVirt/Foreign.chs" #-}

getDomainInfo :: Domain -> IO DomainInfo
getDomainInfo (Domain dptr) = do
  allocaBytes 24 $ \iptr -> do
         i <- virDomainGetInfo (castPtr dptr) iptr
         state   <- (\ptr -> do {peekByteOff ptr 0 ::IO CUChar})     iptr
         maxmem  <- (\ptr -> do {peekByteOff ptr 4 ::IO CULong})    iptr
         memory  <- (\ptr -> do {peekByteOff ptr 8 ::IO CULong})    iptr
         ncpus   <- (\ptr -> do {peekByteOff ptr 12 ::IO CUShort}) iptr
         cputime <- (\ptr -> do {peekByteOff ptr 16 ::IO CULLong})   iptr
         return $ DomainInfo {
                    diState     = cuchar2state state,
                    diMaxMem    = fromIntegral maxmem,
                    diMemory    = fromIntegral memory,
                    diNrVirtCPU = fromIntegral ncpus,
                    diCPUTime   = fromIntegral cputime }

defineDomainXML :: Connection -> String -> IO (Domain)
defineDomainXML a1 a2 =
  let {a1' = connectionToPtr a1} in 
  withCString a2 $ \a2' -> 
  defineDomainXML'_ a1' a2' >>= \res ->
  let {res' = ptrToDomain res} in
  return (res')
{-# LINE 188 "System/LibVirt/Foreign.chs" #-}

undefineDomain :: Domain -> IO (Int)
undefineDomain a1 =
  let {a1' = domainToPtr a1} in 
  undefineDomain'_ a1' >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 191 "System/LibVirt/Foreign.chs" #-}

createDomain :: Domain -> IO (Int)
createDomain a1 =
  let {a1' = domainToPtr a1} in 
  createDomain'_ a1' >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 194 "System/LibVirt/Foreign.chs" #-}

createDomainXML :: Connection -> String -> [DomainCreateFlags] -> IO (Domain)
createDomainXML a1 a2 a3 =
  let {a1' = connectionToPtr a1} in 
  withCString a2 $ \a2' -> 
  let {a3' = flags2int a3} in 
  createDomainXML'_ a1' a2' a3' >>= \res ->
  let {res' = ptrToDomain res} in
  return (res')
{-# LINE 199 "System/LibVirt/Foreign.chs" #-}

getDomainXML :: Domain -> [DomainXMLFlags] -> IO (String)
getDomainXML a1 a2 =
  let {a1' = domainToPtr a1} in 
  let {a2' = flags2int a2} in 
  getDomainXML'_ a1' a2' >>= \res ->
  peekCString res >>= \res' ->
  return (res')
{-# LINE 203 "System/LibVirt/Foreign.chs" #-}

shutdownDomain :: Domain -> IO (Int)
shutdownDomain a1 =
  let {a1' = domainToPtr a1} in 
  shutdownDomain'_ a1' >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 206 "System/LibVirt/Foreign.chs" #-}

rebootDomain :: Domain -> CUInt -> IO (Int)
rebootDomain a1 a2 =
  let {a1' = domainToPtr a1} in 
  let {a2' = id a2} in 
  rebootDomain'_ a1' a2' >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 210 "System/LibVirt/Foreign.chs" #-}

destroyDomain :: Domain -> IO (Int)
destroyDomain a1 =
  let {a1' = domainToPtr a1} in 
  destroyDomain'_ a1' >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 213 "System/LibVirt/Foreign.chs" #-}

refDomain :: Domain -> IO (Int)
refDomain a1 =
  let {a1' = domainToPtr a1} in 
  refDomain'_ a1' >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 216 "System/LibVirt/Foreign.chs" #-}

freeDomain :: Domain -> IO (Int)
freeDomain a1 =
  let {a1' = domainToPtr a1} in 
  freeDomain'_ a1' >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 219 "System/LibVirt/Foreign.chs" #-}

suspendDomain :: Domain -> IO (Int)
suspendDomain a1 =
  let {a1' = domainToPtr a1} in 
  suspendDomain'_ a1' >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 222 "System/LibVirt/Foreign.chs" #-}

resumeDomain :: Domain -> IO (Int)
resumeDomain a1 =
  let {a1' = domainToPtr a1} in 
  resumeDomain'_ a1' >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 225 "System/LibVirt/Foreign.chs" #-}

saveDomain :: Domain -> String -> IO (Int)
saveDomain a1 a2 =
  let {a1' = domainToPtr a1} in 
  withCString a2 $ \a2' -> 
  saveDomain'_ a1' a2' >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 229 "System/LibVirt/Foreign.chs" #-}

restoreDomain :: Connection -> String -> IO (Int)
restoreDomain a1 a2 =
  let {a1' = connectionToPtr a1} in 
  withCString a2 $ \a2' -> 
  restoreDomain'_ a1' a2' >>= \res ->
  let {res' = cIntConv res} in
  return (res')
{-# LINE 233 "System/LibVirt/Foreign.chs" #-}


foreign import ccall safe "System/LibVirt/Foreign.chs.h virInitialize"
  initialize'_ :: (IO CInt)

foreign import ccall safe "System/LibVirt/Foreign.chs.h virConnectOpen"
  openConnection'_ :: ((Ptr CChar) -> (IO (Ptr ())))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virConnectClose"
  closeConnection'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virConnectNumOfDomains"
  runningDomainsCount'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virConnectNumOfDomains"
  virConnectNumOfDomains :: ((Ptr ()) -> (IO CInt))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virConnectListDomains"
  virConnectListDomains :: ((Ptr ()) -> ((Ptr CInt) -> (CInt -> (IO CInt))))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virConnectNumOfDefinedDomains"
  virConnectNumOfDefinedDomains :: ((Ptr ()) -> (IO CInt))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virConnectListDefinedDomains"
  virConnectListDefinedDomains :: ((Ptr ()) -> ((Ptr (Ptr CChar)) -> (CInt -> (IO CInt))))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainLookupByID"
  lookupDomainID'_ :: ((Ptr ()) -> (CInt -> (IO (Ptr ()))))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainLookupByName"
  lookupDomainName'_ :: ((Ptr ()) -> ((Ptr CChar) -> (IO (Ptr ()))))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virConnectNumOfDefinedDomains"
  definedDomainsCount'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainGetInfo"
  virDomainGetInfo :: ((Ptr ()) -> ((DomainInfoPtr) -> (IO CInt)))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainDefineXML"
  defineDomainXML'_ :: ((Ptr ()) -> ((Ptr CChar) -> (IO (Ptr ()))))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainUndefine"
  undefineDomain'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainCreate"
  createDomain'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainCreateXML"
  createDomainXML'_ :: ((Ptr ()) -> ((Ptr CChar) -> (CUInt -> (IO (Ptr ())))))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainGetXMLDesc"
  getDomainXML'_ :: ((Ptr ()) -> (CInt -> (IO (Ptr CChar))))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainShutdown"
  shutdownDomain'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainReboot"
  rebootDomain'_ :: ((Ptr ()) -> (CUInt -> (IO CInt)))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainDestroy"
  destroyDomain'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainRef"
  refDomain'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainFree"
  freeDomain'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainSuspend"
  suspendDomain'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainResume"
  resumeDomain'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainSave"
  saveDomain'_ :: ((Ptr ()) -> ((Ptr CChar) -> (IO CInt)))

foreign import ccall safe "System/LibVirt/Foreign.chs.h virDomainRestore"
  restoreDomain'_ :: ((Ptr ()) -> ((Ptr CChar) -> (IO CInt)))
